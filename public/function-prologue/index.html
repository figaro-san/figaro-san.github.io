<!DOCTYPE html>
<html lang="en">

<head>
    <title>Figaro&#x27;s Blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://figaro-san.github.io/style.css">
    <link rel="stylesheet" href="https://figaro-san.github.io/color/green.css">

        <link rel="stylesheet" href="https://figaro-san.github.io/color/background_dark.css">
    
    <link rel="stylesheet" href="https://figaro-san.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="Figaro's Blog">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://figaro-san.github.io/function-prologue/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="Figaro's Blog">
    <meta property="twitter:domain" content="figaro-san.github.io">
    <meta property="twitter:url" content="https://figaro-san.github.io/function-prologue/">

        <link rel="shortcut icon" type="image&#x2F;x-icon" href="/butterfly.jpg">
    
    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://figaro-san.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Figaro&#x27;s Blog
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://figaro-san.github.io">blog</a></li>
            
                <li><a href="https://figaro-san.github.io/tags">tags</a></li>
            
                <li><a href="https://figaro-san.github.io/whoami">whoami</a></li>
            
                <li><a href="https://figaro-san.github.io/about">about</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://figaro-san.github.io/function-prologue/"> > 関数のプロローグについて</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2023-07-09
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://figaro-san.github.io/tags/asm/">#Asm</a>&nbsp;
                <a class="post-tag" href="https://figaro-san.github.io/tags/c/">#C</a>&nbsp;
                <a class="post-tag" href="https://figaro-san.github.io/tags/pwn/">#Pwn</a>&nbsp;
                <a class="post-tag" href="https://figaro-san.github.io/tags/tech/">#Tech</a></span>
    

        <div class="post-content">
            <h1 id="konoji-shi-nituite">この記事について</h1>
<p>自分がよく忘れがちな関数のプロローグについてまとめようと思い掲載した。</p>
<h1 id="guan-shu-nopurorogunituite">関数のプロローグについて</h1>
<p><strong>関数のプロローグとは、関数を呼び出して実行し、呼び出し元に戻る際に必要となる情報(局所変数のメモリ、rbp、戻りアドレスなど)をスタックに積み上げる処理のことを指す</strong></p>
<p>関数のプロローグを実際に確認するため、以下のようなプログラムを考えてみる。あくまで、関数のプロローグを見るための適当なプログラムである。</p>
<pre data-lang="c" style="background-color:#151515;color:#e8e8d3;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">stdio.h</span><span style="color:#556633;">&gt;
</span><span>
</span><span style="color:#8fbfdc;">void  </span><span style="color:#fad07a;">func</span><span>(</span><span style="color:#8fbfdc;">void</span><span>)
</span><span>{
</span><span>	</span><span style="color:#8fbfdc;">int</span><span> x = </span><span style="color:#cf6a4c;">100</span><span>;
</span><span>	</span><span style="color:#8fbfdc;">char</span><span> str[] = </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hello, World!</span><span style="color:#556633;">&quot;</span><span>;
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span>(</span><span style="color:#8fbfdc;">void</span><span>)
</span><span>{
</span><span>	</span><span style="color:#ffb964;">func</span><span>();
</span><span>	</span><span style="color:#8fbfdc;">return </span><span style="color:#cf6a4c;">0</span><span>;
</span><span>}
</span></code></pre>
<p>これをコンパイルしつつデバッグ情報を付与した後に、GDBデバッガを起動させる。</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">gcc -o</span><span> test test.c</span><span style="color:#ffb964;"> -g
</span><span style="color:#ffb964;">gdb -q</span><span> ./test
</span></code></pre>
<p>GDBデバッガに入ったら、まずは個人的に分かりやすいと思っているintel記法へと設定。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>(gdb) set disassembly-flavor intel
</span></code></pre>
<p>いよいよ本題。ソースコードをアセンブリとして表示してみる。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>(gdb) disass main
</span><span>Dump of assembler code for function main:
</span><span>   0x000055555555519d &lt;+0&gt;:     endbr64
</span><span>   0x00005555555551a1 &lt;+4&gt;:     push   rbp
</span><span>   0x00005555555551a2 &lt;+5&gt;:     mov    rbp,rsp
</span><span>   0x00005555555551a5 &lt;+8&gt;:     call   0x555555555149 &lt;func&gt;
</span><span>   0x00005555555551aa &lt;+13&gt;:    mov    eax,0x0
</span><span>   0x00005555555551af &lt;+18&gt;:    pop    rbp
</span><span>   0x00005555555551b0 &lt;+19&gt;:    ret
</span><span>End of assembler dump.
</span><span>
</span><span>(gdb) disass func
</span><span>   0x0000555555555149 &lt;+0&gt;:     endbr64
</span><span>   0x000055555555514d &lt;+4&gt;:     push   rbp
</span><span>   0x000055555555514e &lt;+5&gt;:     mov    rbp,rsp
</span><span>   0x0000555555555151 &lt;+8&gt;:     sub    rsp,0x20
</span><span>   0x0000555555555155 &lt;+12&gt;:    mov    rax,QWORD PTR fs:0x28
</span><span>   0x000055555555515e &lt;+21&gt;:    mov    QWORD PTR [rbp-0x8],rax
</span><span>   0x0000555555555162 &lt;+25&gt;:    xor    eax,eax
</span><span>   0x0000555555555164 &lt;+27&gt;:    mov    DWORD PTR [rbp-0x1c],0x64
</span><span>   0x000055555555516b &lt;+34&gt;:    movabs rax,0x57202c6f6c6c6548
</span><span>   0x0000555555555175 &lt;+44&gt;:    mov    QWORD PTR [rbp-0x16],rax
</span><span>   0x0000555555555179 &lt;+48&gt;:    mov    DWORD PTR [rbp-0xe],0x646c726f
</span><span>   0x0000555555555180 &lt;+55&gt;:    mov    WORD PTR [rbp-0xa],0x21
</span><span>   0x0000555555555186 &lt;+61&gt;:    nop
</span><span>   0x0000555555555187 &lt;+62&gt;:    mov    rax,QWORD PTR [rbp-0x8]
</span><span>   0x000055555555518b &lt;+66&gt;:    sub    rax,QWORD PTR fs:0x28
</span><span>   0x0000555555555194 &lt;+75&gt;:    je     0x55555555519b &lt;func+82&gt;
</span><span>   0x0000555555555196 &lt;+77&gt;:    call   0x555555555050 &lt;__stack_chk_fail@plt&gt;
</span><span>   0x000055555555519b &lt;+82&gt;:    leave
</span><span>   0x000055555555519c &lt;+83&gt;:    ret
</span><span>End of assembler dump.
</span></code></pre>
<p>特に、func関数のアセンブリの中にある</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x000055555555514d &lt;+4&gt;:     push   rbp
</span><span>   0x000055555555514e &lt;+5&gt;:     mov    rbp,rsp
</span><span>   0x0000555555555151 &lt;+8&gt;:     sub    rsp,0x20
</span></code></pre>
<p>この部分こそが関数のプロローグと呼ばれる処理である。</p>
<h1 id="naniwositeirunoka">なにをしているのか?</h1>
<p>最初に述べたように、関数のプロローグは、関数の実行と呼び出し元に戻るための情報をスタックに積み上げる。関数のプロローグを理解するためには、rspレジスタとrbpレジスタの理解から始めよう。rspとrbpは適当な話、スタックに積まれた一つのフレーム(関数実行時に必要となる情報の集まり)の上下のアドレスを保持している。<strong>つまりrspとrbpが保持しているアドレスの間に局所変数などか格納されているということ。</strong></p>
<p>func関数を呼び出す前と、呼び出されてfuncの処理が行われているときのrspとrbpが持つアドレスを見てみよう。まずはbreakコマンドにより、7行目(func関数内)と11行目(func関数呼び出し前)にブレイクポイントを設定し、runコマンドで最初のブレイクポイント、func関数呼び出し前の11行目で処理を停止させてみる。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>(gdb) break 7
</span><span>(gdb) break 11
</span><span>(gdb) run
</span></code></pre>
<p>次にfunc関数を呼び出す前のrspとrbpが保持するアドレスについて見ていく。以下のコマンドで、レジスタが保持している値を確認できる。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>(gdb) i r $rsp $rbp
</span><span>rsp            0x7fffffffe060      0x7fffffffe060
</span><span>rbp            0x7fffffffe060      0x7fffffffe060
</span></code></pre>
<p>先程、rspとrbpが保持しているアドレスの間に局所変数などか格納されていると書いたが、main関数内では局所変数を宣言していないため、スタック上には領域が確保されていないのです。つまりrspとrbpの値は同じアドレスを指しているということになる。</p>
<p>funcを呼び出す前のスタックの状態が確認ができたら、次はfunc実行中のの状態を確認してみる。contコマンドで、次のブレイクポイントである7行目(func関数内)へと処理を進め、先ほどと同じinfo registerコマンドを使用して、レジスタを確認。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>(gdb) cont
</span><span>(gdb) i r $rsp $rbp
</span><span>rsp            0x7fffffffe030      0x7fffffffe030
</span><span>rbp            0x7fffffffe050      0x7fffffffe050
</span></code></pre>
<p>アドレスが先程よりも小さくなっていることが分かると思う。これはmain関数のスタックフレームが存在している0x7fffffffe060の上にfunc関数のスタックフレーム(関数実行に必要な情報)が積み上げられたためである。またrspとrbpには0x20の差がありますが、この差の中に局所変数などが格納されている。</p>
<h1 id="moushao-sixiang-siku">もう少し詳しく</h1>
<p>今度は命令を追って、具体的に値が変更される流れを見ていこう。今のスタックのイメージは先程のrsp・rbpのアドレスを参考に、このような状態からスタートする。
<img src="/function_prologue/1.avif" alt="stack1.jpg" /></p>
<p>まずはmain関数内にあるcall命令から。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x00005555555551a5 &lt;+8&gt;:     call   0x555555555149 &lt;func&gt;
</span></code></pre>
<p><strong>call命令は戻りアドレスをスタックへpush(積み上げ)し、ripを呼び出し先の関数の先頭アドレスに変更する。</strong>
<strong>また、戻りアドレスとはmain関数内のcall命令の次の命令のアドレスを意味する。</strong></p>
<p>つまり以下の命令のアドレスが、戻りアドレスとして0x7fffffffe060の上にpushされるということになる。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x00005555555551aa &lt;+13&gt;:    mov    eax,0x0
</span></code></pre>
<p><strong>そしてpushを行った場合、rspは減算される。</strong>
つまりrspは、保持している0x7fffffffe060から0x8が減算されて0x7fffffffe058という値を格納する。
<img src="/function_prologue/2.avif" alt="stack2.jpg" /></p>
<p>また、ripに格納される呼び出し先の関数(func)の先頭アドレスはこれ。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x0000555555555149 &lt;+0&gt;:     endbr64
</span></code></pre>
<p>ripとは次に実行する命令のアドレスを保持するレジスタのことで、プロセッサはこれを使って次の命令の場所を把握して実行する。call命令を使用することで、呼び出し先の関数の命令が格納されているアドレスへとripを書き換え、関数の実行が実現する。</p>
<p>では次の命令、つまり関数のプロローグ最初の命令を見ていこう。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x000055555555514d &lt;+4&gt;:     push   rbp
</span></code></pre>
<p>これは、rbpをスタックへとpushする命令。main関数へ制御を返す際にrbpの値を復元するために後々用いられる。0x7fffffffe058の上にrbpの現在の値がpushされるため、rspのアドレスは先ほどと同じように0x8だけ小さくなるので0x7fffffffe050となる。
<img src="/function_prologue/3.avif" alt="stack3.jpg" /></p>
<p>次の命令はrbpへrspのアドレスをmov命令によってコピーする。これによって作成するfunc関数のスタックフレーム、そのボトムをrbpが表すようになる。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x000055555555514e &lt;+5&gt;:     mov    rbp,rsp
</span></code></pre>
<p><img src="/function_prologue/3.avif" alt="stack4.jpg" /></p>
<p>これで、関数から呼び出し元へと帰る際の準備が完了。あとは局所変数などを格納するためにrspの値を減算して領域を確保するだけ。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>   0x0000555555555151 &lt;+8&gt;:     sub    rsp,0x20
</span></code></pre>
<p>sub命令はrspから0x20を引き算するよう命令している。
<img src="/function_prologue/5.avif" alt="stack5.jpg" /></p>
<p>これにて関数プロローグを全て追うことができた。</p>
<h1 id="que-ren">確認</h1>
<p>本当に一連の動作が行われているのかを確認していこう。examineコマンドを使用してrspのアドレスからmain関数のフレームである0x7fffffffe060のあたりまでを確認。</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>(gdb) x/8xg $rsp
</span><span>0x7fffffffe030: 0x0000006400000002      0x2c6f6c6c6548fbff
</span><span>0x7fffffffe040: 0x0021646c726f5720      0xfea8e158512f7600
</span><span>0x7fffffffe050: 0x00007fffffffe060      0x00005555555551aa
</span><span>0x7fffffffe060: 0x0000000000000001      0x00007ffff7db8d90
</span></code></pre>
<p>下から2行目には右に戻りアドレス、左にrbpが格納されていることが確認できる。
また、上から1行目の4バイトまでを数えると0x00000064が格納されており、これは10進数の100であることもわかる。さらには上から2行目の右側と、3行目の左側の値をASCIIコード表と比べてみると</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>0x 2c 6f 6c 6c 65 48 fb ff
</span><span>   ,  o  l  l  e  H
</span><span>
</span><span>0x 00 21 64 6c 72 6f 57 20
</span><span>   \0 !  d  l  r  o  W  Space
</span></code></pre>
<p>上記のように、Hello, World! が確認できる。</p>

        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                    <hr />
                </div>
                <div class="pagination__buttons">
                    
                        <span class="button next">
                            <a href="https://figaro-san.github.io/diver-osint-ctf/">
                                <span class="button__text">DIVER OSINT CTF writeup</span>&nbsp;
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    </div>
            </div>
        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
